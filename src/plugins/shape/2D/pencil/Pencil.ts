/* * @Author: Bigpawn * @Date: 2018/7/12 10:45 * @Last Modified by: Bigpawn * @Last Modified time: 2018/7/12 10:45 * path 最后一个L改成Q ，然后拼接最后一个点生成的path * // 相同点只添加一次  大于两个点才能调用convertPointsToSVGPath */import {fabric} from "fabric";import {AbstractShapePlugin} from '../../AbstractShapePlugin';import {IEvent} from '~fabric/fabric-impl';import {Pencil as FabricPencil} from "../../../../extends/Pencil";import {    authorityAssist,    message,    setCursor,} from '../../../../utils/decorators';import {IPencilMessage} from '../../../../interface/IMessage';import {MessageTag} from '../../../../enums/MessageTag';import {CursorType} from '../../../../enums/CursorType';@setCursor(CursorType.SystemCross)class Pencil extends AbstractShapePlugin{    private points:fabric.Point[]=[];    private path:string="";    public instance:FabricPencil;    protected get stroke(){        return this._stroke||this.context.pencilColor||this.context.config.stroke;    }    private addPoint(point:fabric.Point){        const length = this.points.length;        if(length === 0){            this.points.push(point);            this.calcPath();        }else{            const last = this.points[length-1];            if(last.x === point.x && last.y === point.y){                // 不添加            }else{                this.points.push(point);                this.calcPath();            }        }    }    private static calcQPoint(start:{x:number;y:number}, end:{x:number;y:number}){        let t =0.5;        return {            x:start.x+ (end.x - start.x) * t,            y:start.y + (end.y - start.y) * t        };    }    private calcPath(){        const length = this.points.length;        if(length === 0){            this.path="";        }else if(length===1){            const start = this.points[0];            this.path = `M ${start.x} ${start.y} L ${start.x} ${start.y+0.001}`;            this.update();        }else if(length === 2){            const start = this.points[0];            const end = this.points[1];            const qPoint = Pencil.calcQPoint(start,end);            this.path = `M ${start.x} ${start.y} Q ${start.x} ${start.y} ${qPoint.x} ${qPoint.y} L ${end.x} ${end.y}`;            this.update();        }else{            const last = this.points.slice(length-2);            const lastL = this.path.lastIndexOf("L");            const replace = this.path.substring(0,lastL);            const start = last[0];            const end = last[1];            const qPoint = Pencil.calcQPoint(start,end);            const lastString = `Q ${start.x} ${start.y} ${qPoint.x} ${qPoint.y} L ${end.x} ${end.y}`;            this.path = replace + lastString;            this.update();        }    }    @message    private throw(){        return this.instance?{            id:this.instance.id,            tag:MessageTag.Shape,            path:this.path,            type:this.instance.type,            stroke:this.instance.stroke,            strokeWidth:this.instance.strokeWidth,            strokeDashArray:this.instance.strokeDashArray        }:undefined    }    private update(){        this.eBoardCanvas.renderOnAddRemove=false;        if(void 0 !== this.instance){            this.eBoardCanvas.remove(this.instance);        }        const id = this.instance?this.instance.id:undefined;        this.instance=new FabricPencil(this.path,{            stroke: this.stroke,            strokeWidth:this.pencilWidth,            fill:undefined,            strokeDashArray:this.strokeDashArray,        },this.eBoardCanvas);        if(void 0 !== id){            this.instance.setId(id);        }        this.throw();        this.eBoardCanvas.add(this.instance);        this.eBoardCanvas.renderAll();        this.eBoardCanvas.renderOnAddRemove=true;    }    @authorityAssist    protected onMouseDown(event:IEvent){        super.onMouseDown(event);        this.addPoint(new fabric.Point(this.start.x,this.start.y));    }    @authorityAssist    protected onMouseMove(event:IEvent){        if(void 0 === this.start){            return;        }        super.onMouseMove(event);        this.addPoint(new fabric.Point(this.end.x,this.end.y));    }    @authorityAssist    protected onMouseUp(event:IEvent){        if(void 0 !== this.end){            this.addPoint(new fabric.Point(this.end.x,this.end.y));        }        super.onMouseUp(event);        this.points=[];        this.path="";        this.end=undefined as any;    }            public onMessage(message:IPencilMessage){        const {id,path,stroke,strokeDashArray,strokeWidth} = message;        let instance = this.getInstanceById(id) as FabricPencil;        this.eBoardCanvas.renderOnAddRemove=false;            if(void 0 !== instance){            this.eBoardCanvas.remove(instance);        }        console.log({            stroke: stroke,            // fill:undefined,            strokeWidth,            strokeDashArray        });        instance = new FabricPencil(path,{            stroke: stroke,            fill:undefined,            strokeWidth,            ...strokeDashArray?{strokeDashArray}:{},        },this.eBoardCanvas).setId(id);        this.eBoardCanvas.add(instance);        this.eBoardCanvas.requestRenderAll();        this.eBoardCanvas.renderOnAddRemove=true;    }}export {Pencil};